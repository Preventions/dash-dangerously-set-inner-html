# Auto-generated by dashTranspileR -- do not edit by hand

#' DangerouslySetInnerHTML component
#' @description Render a string of raw, unescaped HTML. This uses React.js's `dangerouslySetInnerHTML` method. From React.js's documentation, note that: > Setting HTML from code is risky because it's easy to > inadvertently expose your users to a cross-site scripting (XSS) > (https://en.wikipedia.org/wiki/Cross-site_scripting) > attack. So, you can set HTML directly in Dash through React.js, but you have to type out dangerouslySetInnerHTML to remind yourself that it's dangerous.  In most cases, you are safer using the Dash HTML component classes, dash-html-components (https://github.com/plotly/dash-html-components). You can also provide HTML in a sandboxed iframe using the `dash_html_components.IFrame(srcDoc='raw html here')` component, see , see https://community.plot.ly/t/rendering-html-similar-to-markdown/6232/2?u=chriddyp  Note that the elements in the HTML block that is generated will can not be targeted with Dash callbacks.
#' @export
#' @param ... An string of raw, unescaped HTML that will be rendered directly  
#' @param children An string of raw, unescaped HTML that will be rendered directly 

DangerouslySetInnerHTML <- function(..., children = NULL) {

component <- list(
  props = list(
    children=c(children, assert_valid_children(..., wildcards = NULL))
  ),
  type = 'DangerouslySetInnerHTML',
  namespace = 'dash_dangerously_set_inner_html',
  propNames = c('children'),
  package = 'dashDangerouslySetInnerHtml'
)

component$props <- filter_null(component$props)


structure(component, class = c('dash_component', 'list'))
}


filter_null <- function(x) {
  if (length(x) == 0 || !is.list(x)) return(x)
  x[!vapply(x, is.null, logical(1))]
}

assert_valid_children <- function(..., wildcards = NULL) {
  kids <- list(...)
  if (length(wildcards)) {
    pattern <- paste(paste0('^', wildcards), collapse = '|')
    kids <- kids[!grepl(pattern, names2(kids))]
  }
  if (!length(kids)) return(NULL)
  assert_no_names(kids)
}

append_wildcard_props <- function(component, wildcards = NULL, ...) {
  attrs <- list(...)
  if (!length(attrs) || !length(wildcards)) return(component)
  pattern <- paste(paste0('^', wildcards), collapse = '|')
  attrs_wild <- attrs[grepl(pattern, names2(attrs))]
  if (!length(attrs_wild)) return(component)
  component[['props']] <- c(component[['props']] %||% list(), attrs_wild)
  component[['propNames']] <- c(component[['propNames']], names(attrs_wild))
  component
}

names2 <- function(x) names(x) %||% rep('', length(x))

`%||%` <- function(x, y) if (length(x)) x else y

assert_no_names <- function(x) {
  nms <- names(x)
  if (!is.null(nms)) {
    stop(
      sprintf(
        "Didn't recognize the following named arguments: '%s'",
         paste(nms, collapse = "', '")
       ), call. = FALSE
    )
  }
  names(x) <- NULL
  x
}
